# src/analyzers/vulnerability_analyzer.py
import os
from typing import Dict, Any, List
import networkx as nx
from src.models.claude_agent import ClaudeAgent

class VulnerabilityAnalyzer:
    def __init__(self, claude_agent: ClaudeAgent):
        self.claude_agent = claude_agent

    def analyze_simulation_results(self, simulation_results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze multiple simulation results to generate aggregate metrics"""
        metrics = {
            "success_rate": 0,
            "attack_vectors": {},
            "severity_distribution": {
                "Low": 0,
                "Medium": 0,
                "High": 0,
                "Critical": 0
            }
        }
        
        if not simulation_results:
            return {"metrics": metrics}
            
        # Calculate success rate
        successful_attacks = sum(1 for r in simulation_results if r.get("overall_success", False))
        metrics["success_rate"] = successful_attacks / len(simulation_results)
        
        # Analyze attack vectors and severity
        for result in simulation_results:
            # Count attack vectors
            if "scenario" in result and "attack_vector" in result["scenario"]:
                vector = result["scenario"]["attack_vector"]
                metrics["attack_vectors"][vector] = metrics["attack_vectors"].get(vector, 0) + 1
                
            # Count severity levels
            if "vulnerability_analysis" in result and "severity" in result["vulnerability_analysis"]:
                severity = result["vulnerability_analysis"]["severity"]
                if severity in metrics["severity_distribution"]:
                    metrics["severity_distribution"][severity] += 1
                    
        return {"metrics": metrics}

    def generate_attack_graph(self, simulation_results: List[Dict[str, Any]]) -> nx.DiGraph:
        """Generate an attack graph from simulation results"""
        G = nx.DiGraph()
        
        for result in simulation_results:
            if "scenario" not in result:
                continue
                
            scenario = result["scenario"]
            target = result.get("target", {})
            target_name = target.get("vessel_name", target.get("name", "Unknown Target"))
            
            # Add target node
            G.add_node(target_name, type="target")
            
            # Add attack steps
            prev_node = target_name
            for i, step in enumerate(scenario.get("steps", [])):
                step_id = f"Step {i+1}"
                G.add_node(step_id, type="step")
                G.add_edge(prev_node, step_id)
                prev_node = step_id
                
            # Add outcome
            outcome = "Success" if result.get("overall_success", False) else "Failure"
            G.add_node(outcome, type="outcome")
            G.add_edge(prev_node, outcome)
            
        return G

    def _identify_patterns(self, simulation_results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Identify patterns in attack simulations"""
        patterns = []
        
        # This would be more sophisticated in a real implementation
        # For the hackathon, we'll use a simplified approach
        
        # Check for common initial access methods
        initial_steps = [r.get("scenario", {}).get("steps", ["unknown"])[0] for r in simulation_results]
        common_initial = pd.Series(initial_steps).value_counts().head(3).to_dict()
        
        patterns.append({
            "type": "initial_access",
            "description": "Common initial access methods",
            "data": common_initial
        })
        
        # Check for system type vulnerabilities
        system_vulnerabilities = {}
        for result in simulation_results:
            target_systems = result.get("target", {}).get("systems", [])
            for system in target_systems:
                if system not in system_vulnerabilities:
                    system_vulnerabilities[system] = {"total": 0, "compromised": 0}
                
                system_vulnerabilities[system]["total"] += 1
                if result.get("overall_success", False):
                    system_vulnerabilities[system]["compromised"] += 1
        
        # Calculate compromise rates
        for system, data in system_vulnerabilities.items():
            if data["total"] > 0:
                data["compromise_rate"] = data["compromised"] / data["total"]
            else:
                data["compromise_rate"] = 0
        
        patterns.append({
            "type": "system_vulnerabilities",
            "description": "Vulnerability rates by system type",
            "data": system_vulnerabilities
        })
        
        return patterns
    
    def _generate_recommendations(self, simulation_results: List[Dict[str, Any]]) -> List[Dict[str, str]]:
        """Generate recommendations based on simulation results"""
        # In a real implementation, this would use Claude for more sophisticated analysis
        # For the hackathon, we'll use a simplified approach
        
        recommendations = []
        
        # Extract all mitigations from vulnerability analyses
        all_mitigations = []
        for result in simulation_results:
            if "vulnerability_analysis" in result:
                mitigations = result["vulnerability_analysis"].get("mitigations", [])
                all_mitigations.extend(mitigations)
        
        # Count and rank mitigations
        if all_mitigations:
            mitigation_counts = pd.Series(all_mitigations).value_counts().head(5)
            
            for mitigation, count in mitigation_counts.items():
                recommendations.append({
                    "recommendation": mitigation,
                    "frequency": f"Suggested in {count} out of {len(simulation_results)} simulations"
                })
        
        # Add general recommendations
        recommendations.append({
            "recommendation": "Implement regular red team exercises to continuously test defenses",
            "frequency": "General recommendation"
        })
        
        recommendations.append({
            "recommendation": "Establish a vulnerability management program with clear remediation timelines",
            "frequency": "General recommendation"
        })
        
        return recommendations
