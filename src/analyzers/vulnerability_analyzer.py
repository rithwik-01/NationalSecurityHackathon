# src/analyzers/vulnerability_analyzer.py
from typing import Dict, List, Any
import pandas as pd
import numpy as np
import networkx as nx
from ..models.claude_agent import ClaudeAgent

class VulnerabilityAnalyzer:
    def __init__(self, claude_agent: ClaudeAgent = None):
        self.claude_agent = claude_agent or ClaudeAgent()
    
    def analyze_simulation_results(self, simulation_results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze simulation results to extract patterns and insights"""
        if not simulation_results:
            return {"error": "No simulation results to analyze"}
        
        # Extract key metrics
        success_rate = sum([1 for r in simulation_results if r.get("overall_success", False)]) / len(simulation_results)
        
        # Analyze attack vectors
        attack_vectors = [r.get("scenario", {}).get("attack_vector", "unknown") for r in simulation_results]
        vector_counts = pd.Series(attack_vectors).value_counts().to_dict()
        
        # Analyze target types
        target_types = [r.get("target", {}).get("type", "unknown") for r in simulation_results]
        target_counts = pd.Series(target_types).value_counts().to_dict()
        
        # Analyze vulnerabilities
        vulnerabilities = []
        for result in simulation_results:
            if "vulnerability_analysis" in result:
                vulnerabilities.append(result["vulnerability_analysis"])
        
        # Calculate severity distribution
        severity_counts = {}
        if vulnerabilities:
            severities = [v.get("severity", "unknown") for v in vulnerabilities]
            severity_counts = pd.Series(severities).value_counts().to_dict()
        
        # Generate recommendations
        recommendations = self._generate_recommendations(simulation_results)
        
        return {
            "metrics": {
                "total_simulations": len(simulation_results),
                "success_rate": success_rate,
                "attack_vectors": vector_counts,
                "target_types": target_counts,
                "severity_distribution": severity_counts
            },
            "patterns": self._identify_patterns(simulation_results),
            "recommendations": recommendations
        }
    
    def _identify_patterns(self, simulation_results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Identify patterns in attack simulations"""
        patterns = []
        
        # This would be more sophisticated in a real implementation
        # For the hackathon, we'll use a simplified approach
        
        # Check for common initial access methods
        initial_steps = [r.get("scenario", {}).get("steps", ["unknown"])[0] for r in simulation_results]
        common_initial = pd.Series(initial_steps).value_counts().head(3).to_dict()
        
        patterns.append({
            "type": "initial_access",
            "description": "Common initial access methods",
            "data": common_initial
        })
        
        # Check for system type vulnerabilities
        system_vulnerabilities = {}
        for result in simulation_results:
            target_systems = result.get("target", {}).get("systems", [])
            for system in target_systems:
                if system not in system_vulnerabilities:
                    system_vulnerabilities[system] = {"total": 0, "compromised": 0}
                
                system_vulnerabilities[system]["total"] += 1
                if result.get("overall_success", False):
                    system_vulnerabilities[system]["compromised"] += 1
        
        # Calculate compromise rates
        for system, data in system_vulnerabilities.items():
            if data["total"] > 0:
                data["compromise_rate"] = data["compromised"] / data["total"]
            else:
                data["compromise_rate"] = 0
        
        patterns.append({
            "type": "system_vulnerabilities",
            "description": "Vulnerability rates by system type",
            "data": system_vulnerabilities
        })
        
        return patterns
    
    def _generate_recommendations(self, simulation_results: List[Dict[str, Any]]) -> List[Dict[str, str]]:
        """Generate recommendations based on simulation results"""
        # In a real implementation, this would use Claude for more sophisticated analysis
        # For the hackathon, we'll use a simplified approach
        
        recommendations = []
        
        # Extract all mitigations from vulnerability analyses
        all_mitigations = []
        for result in simulation_results:
            if "vulnerability_analysis" in result:
                mitigations = result["vulnerability_analysis"].get("mitigations", [])
                all_mitigations.extend(mitigations)
        
        # Count and rank mitigations
        if all_mitigations:
            mitigation_counts = pd.Series(all_mitigations).value_counts().head(5)
            
            for mitigation, count in mitigation_counts.items():
                recommendations.append({
                    "recommendation": mitigation,
                    "frequency": f"Suggested in {count} out of {len(simulation_results)} simulations"
                })
        
        # Add general recommendations
        recommendations.append({
            "recommendation": "Implement regular red team exercises to continuously test defenses",
            "frequency": "General recommendation"
        })
        
        recommendations.append({
            "recommendation": "Establish a vulnerability management program with clear remediation timelines",
            "frequency": "General recommendation"
        })
        
        return recommendations
    
    def generate_attack_graph(self, simulation_results: List[Dict[str, Any]]) -> nx.DiGraph:
        """Generate an attack graph from simulation results"""
        G = nx.DiGraph()
        
        for result in simulation_results:
            if "simulation_results" not in result:
                continue
            
            target_name = result.get("target", {}).get("name", "Unknown Target")
            G.add_node(target_name, type="target")
            
            steps = result["simulation_results"]
            prev_node = target_name
            
            for i, step in enumerate(steps):
                step_name = f"Step {i+1}: {step['description'][:30]}..."
                G.add_node(step_name, type="step", success=step["success"])
                G.add_edge(prev_node, step_name)
                prev_node = step_name
            
            if result.get("overall_success", False):
                G.add_node("Compromise", type="outcome", success=True)
                G.add_edge(prev_node, "Compromise")
            else:
                G.add_node("Defense Successful", type="outcome", success=False)
                G.add_edge(prev_node, "Defense Successful")
        
        return G
